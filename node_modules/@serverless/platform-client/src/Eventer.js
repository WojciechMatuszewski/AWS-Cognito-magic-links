'use strict';

const utils = require('./utils');

class Eventer {
  constructor(sdk) {
    this.sdk = sdk;
  }

  /**
   * Validate a publish event request
   * @param {*} event
   */
  validate(event) {
    if (!event) {
      throw new Error('An "event" is required');
    }
    if (typeof event !== 'object') {
      throw new Error('The "event" argument must be an object');
    }
    if (!event.event || typeof event.event !== 'string') {
      throw new Error(
        'The "event" property containing the event type is required and must be a string'
      );
    }
    return event;
  }

  /**
   * Convert to a safe Serverless Platform Event
   * @param {*} event
   */
  transform(event) {
    const safeEvent = {
      access_key: this.sdk.accessKey,
      event: event.event.trim(),
      org_uid: event.orgUid || this.sdk.context.orgUid,
      org_name: event.orgName || this.sdk.context.orgName,
      stage_name: this.sdk.context.stageName,
      app_name: this.sdk.context.appName,
      instance_name: this.sdk.context.instanceName,
      component_name: this.sdk.context.componentName,
      component_version: this.sdk.context.componentVersion,
      data: event.data || {},
      created: event.created || Date.now(),
    };

    if (!safeEvent.org_name && !safeEvent.org_uid) {
      throw new Error('event must have an "orgName" or "orgUid"');
    }

    return safeEvent;
  }

  /**
   * Send an event via the Websockets connection.
   * @param {*} event
   */
  send(event) {
    const safeEvent = this.transform(this.validate(event));
    if (!this.sdk.isConnected()) {
      throw new Error('You are not currently connected to the Serverless Platform.');
    }
    this.sdk.connection.send(JSON.stringify(safeEvent));
  }

  request(api, method = 'GET', data) {
    return utils.request({
      endpoint: `${this.sdk.getDomain('events')}${api}`,
      accessKey: this.sdk.accessKey,
      method,
      data,
    });
  }

  /**
   * Publish an event synchornously, via the HTTP API
   * @param {*} event
   */
  publish(event) {
    const safeEvent = this.transform(this.validate(event));
    return this.request('/publish', 'POST', safeEvent);
  }

  /**
   * Retrieve a Serverless Platform Event synchronously via HTTP API.
   * @param {string} eventUid UID of event to be fetched
   */
  getEvent(eventUid) {
    return this.request(`/events/${eventUid}`);
  }

  /**
   * Retrieve a Serverless Platform Event synchronously via HTTP API.
   * @param {Object} options List options
   */
  listEvents(options) {
    const {
      org_name: orgName = null,
      org_uid: orgUid = null,
      event = '*',
      limit = 10,
      created,
      starting_after: startingAfter,
    } = options || {};

    const params = new URLSearchParams({ event, limit });

    if (orgUid) {
      params.append('org_uid', orgUid);
    } else if (orgName) {
      params.append('org_name', orgName);
    } else if (this.sdk.context.orgUid) {
      params.append('org_uid', this.sdk.context.orgUid);
    } else if (this.sdk.context.orgName) {
      params.append('org_name', this.sdk.context.orgName);
    }

    if (created) {
      if (new Set(['number', 'string']).has(typeof created)) {
        params.append('created.gt', created);
      } else if (typeof event !== 'object') {
        let valid = false;
        for (const comparator of ['gt', 'gte', 'lt', 'lte']) {
          if (created[comparator]) {
            params.append(`created.${comparator}`, created[comparator]);
            valid = true;
            break;
          }
        }
        if (!valid) {
          throw new Error(
            "The 'created' dictionary parameter must have one of [gt|gte|lt|lte] set"
          );
        }
      } else {
        throw new Error(
          "The 'created' parameter must be either a integer Unix timestamp or a dictionary"
        );
      }
    }

    if (startingAfter) {
      params.append('starting_after', startingAfter);
    }

    const endpoint = `/events?${params.toString()}`;
    return this.request(endpoint);
  }
}

module.exports = Eventer;
